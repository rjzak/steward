use crate::crypto::*;

use std::fmt::Debug;

use anyhow::{anyhow, Result};

use const_oid::ObjectIdentifier;
use der::{Decodable, Sequence};
use x509::ext::Extension;
use x509::{request::CertReqInfo, Certificate};
use x509::{PkiPath, TbsCertificate};

use super::ExtVerifier;

const QE_VENDOR_INTEL:[u8;16] = [0x93, 0x9A, 0x72, 0x33, 0xF7, 0x9C, 0x4C, 0xA9, 0x94, 0x0A, 0x0D, 0xB3, 0x95, 0x7F, 0x06, 0x07];

#[derive(Clone, Debug, PartialEq, Eq, Sequence)]
pub struct Evidence<'a> {
    pub pck: Certificate<'a>,

    #[asn1(type = "OCTET STRING")]
    pub quote: &'a [u8],
}

#[repr(C,u16)]
#[derive(Copy, Clone, Debug)]
pub enum AttestationKeyType {
    ECDSA256P256 = 2,
    ECDSA384P384 = 3,
}

#[repr(C,u16)]
#[derive(Copy, Clone, Debug)]
pub enum QECertificationType {
    /// PCK identifier PPID in plain text with CPUSVN and PCESVN
    PCKidPPIDPlainCPUSVNPCESVN = 1,
    /// PCK identifier PPID encrypted with RSA-2048 with CPUSVN and PCESVN
    PCKidPPIDEncryptedRSA2048 = 2,
    /// PCK identifier PPID encrypted with RSA-3072 with CPUSVN and PCESVN
    PCKidPPIDEncryptedRSA3072 = 3,
    /// Currently not supported
    PCKLeafCert = 4,
    /// Concatenated certificate and chain
    ConcatenatedPCKCertChain = 5,
    /// Currently not supported
    PlatformManifest = 7,
}

#[repr(C, packed)]
#[derive(Copy, Clone, Debug)]
struct QuoteHeader {
    /// Version of the Quote structure
    pub version: u16,
    /// Type of the attestation key used
    pub att_key_type: AttestationKeyType,
    rsvd: u32,
    /// Security version of the quoting enclave
    pub qe_svn: u16,
    /// Security version of the provisioning certification enclave
    pub pce_svn: u16,
    /// UUID of the QE vendor
    pub qe_vendor_id: [u8; 16],
    /// Custom user-defined data
    pub user_data: [u8; 20]
}

#[repr(C, packed)]
#[derive(Copy, Clone, Debug)]
struct ISVEnclaveReport {
    /// Security version of the CPU
    pub cpu_svn: [u8; 16],
    /// SSA Frame extended features
    pub misc_select: u32,
    /// Reserved
    rsvd1: [u8; 28],
    /// Set of flags describing attributes of the enclave
    pub attributes: [u8; 16],
    /// Hash of enclave measurements
    pub mr_enclave: [u8; 32],
    /// Reserved
    rsvd2: [u8; 32],
    /// Hash of the enclave signing key
    pub mr_signer: [u8; 32],
    /// Reserved
    rsvd3: [u8; 96],
    /// Enclave product ID
    pub isv_prod_id: u16,
    /// Security version of the enclave
    pub isv_svn: u16,
    /// Reserved
    rsvd4: [u8; 60],
    /// Additional report data
    pub report_data: [u8; 64]
}

#[repr(C, packed)]
#[derive(Clone, Debug)]
struct QECertificationData<'a> {
    pub certification_data_type: QECertificationType,
    pub size: u32,
    pub data: &'a [u8],
}

#[repr(C, packed)]
#[derive(Clone, Debug)]
struct QEAuthenticationData<'a> {
    pub size: u16,
    pub data: &'a [u8],
}

#[repr(C, packed)]
#[derive(Clone, Debug)]
struct ECDSA256QuoteData<'a> {
    /// ECDSA signature over the Header and Enclave Report
    pub isv_enclave_report_signature: [u8; 64],
    /// Public part of the ECDSA Attestation Key generated by the Quoting Enclave
    pub ecdsa_attestation_key: [u8; 64],
    pub qe_report: ISVEnclaveReport,
    /// ECDSA signature over the QE Report using the Provisioning Certificate Key
    pub qe_report_signature: [u8; 64],
    /// Additional variable-length data provided by the Quoting Enclave
    pub qe_authentication_data: QEAuthenticationData<'a>,
    /// Data required to verify the QE Report Signature
    pub qe_certification_data: QECertificationData<'a>,
}

#[repr(C, packed)]
#[derive(Clone, Debug)]
struct Sgx<'a> {
    /// Header of the quote data
    pub header: QuoteHeader,
    /// Report of the attested ISV Enclave
    pub isv_enclave_report: ISVEnclaveReport,
    /// Size of the quote signature data structure
    pub quote_signature_len: u32,
    pub quote_signature_data: ECDSA256QuoteData<'a>,
}

impl Sgx {
    const ROOT: &'static [u8] = include_bytes!("sgx.pkipath");

    // This ensures that the supplied pck is rooted in our trusted chain.
    fn is_trusted<'c>(&self, pck: &'c Certificate<'c>) -> Result<&'c TbsCertificate<'c>> {
        let path = PkiPath::from_der(Self::ROOT)?;

        let mut signer = Some(&path.0[0].tbs_certificate);
        for cert in path.0.iter().chain([pck].into_iter()) {
            signer = signer.and_then(|s| s.verify_crt(cert).ok());
        }

        if let Some(signer) = signer {
            if signer == &pck.tbs_certificate {
                return Ok(&pck.tbs_certificate);
            }
        }

        Err(anyhow!("sgx pck is untrusted"))
    }
}

impl ExtVerifier for Sgx {
    const OID: ObjectIdentifier = ObjectIdentifier::new_unwrap("1.3.6.1.4.1.58270.1.2");
    const ATT: bool = true;

    fn verify(&self, cri: &CertReqInfo<'_>, ext: &Extension<'_>, dbg: bool) -> Result<bool> {
        if ext.critical {
            return Err(anyhow!("snp extension cannot be critical"));
        }

        // Decode the evidence.
        let evidence = Evidence::from_der(ext.extn_value)?;

        // Validate the PCK.
        let pck = self.is_trusted(&evidence.pck)?;

        // Force certs to have the same key type as the PCK.
        //
        // A note about this check is in order. We don't want to build crypto
        // algorithm negotiation into this protocol. Not only is it complex
        // but it is also subject to downgrade attacks. For example, if the
        // weakest link in the certificate chain is a P384 key and the
        // attacker downgrades the negotiation to P256, it has just weakened
        // security for the whole chain.
        //
        // We solve this by using forcing the certification request to have
        // the same key type as the VCEK. This means we have no worse security
        // than whatever AMD chose for the VCEK.
        //
        // Additionally, we do this check early to be defensive.
        if cri.public_key.algorithm != pck.subject_public_key_info.algorithm {
            return Err(anyhow!("snp vcek algorithm mismatch"));
        }

        // TODO: validate report
        if !dbg {}

        Ok(true)
    }
}
