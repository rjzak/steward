use crate::crypto::*;

use std::fmt::Debug;

use anyhow::{anyhow, Result};

use const_oid::ObjectIdentifier;
use der::{Decodable, Sequence};
use x509::ext::Extension;
use x509::{request::CertReqInfo, Certificate};
use x509::{PkiPath, TbsCertificate};

use super::ExtVerifier;

const QE_VENDOR_INTEL:[u8;16] = [0x93, 0x9A, 0x72, 0x33, 0xF7, 0x9C, 0x4C, 0xA9, 0x94, 0x0A, 0x0D, 0xB3, 0x95, 0x7F, 0x06, 0x07];

#[derive(Clone, Debug, PartialEq, Eq, Sequence)]
pub struct Evidence<'a> {
    pub pck: Certificate<'a>,

    #[asn1(type = "OCTET STRING")]
    pub quote: &'a [u8],
}

#[repr(u16)]
#[derive(Copy, Clone, Debug)]
pub enum AttestationKeyType {
    ECDSA256P256 = 2,
    ECDSA384P384 = 3,
}

#[repr(u16)]
#[derive(Copy, Clone, Debug)]
pub enum QECertificationType {
    /// PCK identifier PPID in plain text with CPUSVN and PCESVN
    PCKidPPIDPlainCPUSVNPCESVN = 1,
    /// PCK identifier PPID encrypted with RSA-2048 with CPUSVN and PCESVN
    PCKidPPIDEncryptedRSA2048 = 2,
    /// PCK identifier PPID encrypted with RSA-3072 with CPUSVN and PCESVN
    PCKidPPIDEncryptedRSA3072 = 3,
    /// Currently not supported
    PCKLeafCert = 4,
    /// Concatenated certificate and chain
    ConcatenatedPCKCertChain = 5,
    /// Currently not supported
    PlatformManifest = 7,
}

#[repr(C, packed)]
#[derive(Copy, Clone, Debug)]
pub struct QuoteHeader {
    /// Version of the Quote structure
    pub version: u16,
    /// Type of the attestation key used
    pub att_key_type: AttestationKeyType,
    /// Reserved
    rsvd: u32,
    /// Security version of the quoting enclave
    pub qe_svn: u16,
    /// Security version of the provisioning certification enclave
    pub pce_svn: u16,
    /// UUID of the QE vendor
    pub qe_vendor_id: [u8; 16],
    /// Custom user-defined data
    pub user_data: [u8; 20]
}

#[repr(C, packed)]
#[derive(Copy, Clone, Debug)]
pub struct ISVEnclaveReport {
    /// Security version of the CPU
    pub cpu_svn: [u8; 16],
    /// SSA Frame extended features
    pub misc_select: u32,
    /// Reserved
    rsvd1: [u8; 28],
    /// Set of flags describing attributes of the enclave
    pub attributes: [u8; 16],
    /// Hash of enclave measurements
    pub mr_enclave: [u8; 32],
    /// Reserved
    rsvd2: [u8; 32],
    /// Hash of the enclave signing key
    pub mr_signer: [u8; 32],
    /// Reserved
    rsvd3: [u8; 96],
    /// Enclave product ID
    pub isv_prod_id: u16,
    /// Security version of the enclave
    pub isv_svn: u16,
    /// Reserved
    rsvd4: [u8; 60],
    /// Additional report data
    pub report_data: [u8; 64]
}

#[derive(Clone, Debug)]
pub struct QECertificationData {
    pub certification_data_type: QECertificationType,
    pub size: u32,
    pub data: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct QEAuthenticationData {
    pub size: u16,
    pub data: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct ECDSA256QuoteData {
    /// ECDSA signature over the Header and Enclave Report
    pub isv_enclave_report_signature: [u8; 64],
    /// Public part of the ECDSA Attestation Key generated by the Quoting Enclave
    pub ecdsa_attestation_key: [u8; 64],
    pub qe_report: ISVEnclaveReport,
    /// ECDSA signature over the QE Report using the Provisioning Certificate Key
    pub qe_report_signature: [u8; 64],
    /// Additional variable-length data provided by the Quoting Enclave
    pub qe_authentication_data: QEAuthenticationData,
    /// Data required to verify the QE Report Signature
    pub qe_certification_data: QECertificationData,
}

#[derive(Clone, Debug)]
pub struct Quote {
    /// Header of the quote data
    pub header: QuoteHeader,
    /// Report of the attested ISV Enclave
    pub isv_enclave_report: ISVEnclaveReport,
    /// Size of the quote signature data structure
    pub quote_signature_len: u32,
    pub quote_signature_data: ECDSA256QuoteData,
}

#[derive(Copy, Clone, Debug, Default)]
pub struct Sgx(());

fn slice_to_u16(data: &[u8]) -> u16 {
    let mut temp_ints: [u8; 2] = [0; 2];
    temp_ints[0] = data[0];
    temp_ints[1] = data[1];
    u16::from_le_bytes(temp_ints)
}

fn slice_to_u32(data: &[u8]) -> u32 {
    let mut temp_ints: [u8; 4] = [0; 4];
    temp_ints[0] = data[0];
    temp_ints[1] = data[1];
    temp_ints[2] = data[2];
    temp_ints[3] = data[3];
    u32::from_le_bytes(temp_ints)
}

impl Sgx {
    const ROOT: &'static [u8] = include_bytes!("sgx.pkipath");

    // This ensures that the supplied pck is rooted in our trusted chain.
    fn is_trusted<'c>(&self, pck: &'c Certificate<'c>) -> Result<&'c TbsCertificate<'c>> {
        let path = PkiPath::from_der(Self::ROOT)?;

        let mut signer = Some(&path.0[0].tbs_certificate);
        for cert in path.0.iter().chain([pck].into_iter()) {
            signer = signer.and_then(|s| s.verify_crt(cert).ok());
        }

        if let Some(signer) = signer {
            if signer == &pck.tbs_certificate {
                return Ok(&pck.tbs_certificate);
            }
        }

        Err(anyhow!("sgx pck is untrusted"))
    }
}

impl Quote {
    fn from_bytes(data: &[u8]) -> Result<Quote> {
        // Keep our place in the data array
        let mut counter:usize = 0;

        // Start with the Quote header
        let quote_header_version = slice_to_u16(&data[counter..counter+2]);
        counter += 2;
        let quote_header_key_type = match slice_to_u16(&data[counter..counter+2]) {
            2 => AttestationKeyType::ECDSA256P256,
            3 => AttestationKeyType::ECDSA384P384,
            _ => return Err(anyhow!("invalid quote attestation key type"))
        };
        counter += 2;

        // The reserved 32-bit integer
        counter += 4;

        let quote_qe_svn = slice_to_u16(&data[counter..counter+2]);
        counter += 2;
        let quote_pce_svn = slice_to_u16(&data[counter..counter+2]);
        counter += 2;
        let mut quote_qe_vendor_id = [0u8; 16];
        for (index, val) in data[counter..counter+16].iter().enumerate() {
            quote_qe_vendor_id[index] = *val;
        }
        counter += 16;
        let mut quote_user_data = [0u8; 20];
        for (index, val) in data[counter..counter+20].iter().enumerate() {
            quote_user_data[index] = *val;
        }
        counter += 20;

        // The ISV Enclave Report
        let mut isv_cpu_svn = [0u8; 16];
        for (index, val) in data[counter..counter+16].iter().enumerate() {
            isv_cpu_svn[index] = *val;
        }
        counter += 16;

        let isv_misc_select = slice_to_u32(&data[counter..counter+4]);
        counter += 4;

        // The first reserved field, 28 bytes
        counter += 28;

        let mut isv_attributes = [0u8;16];
        for (index, val) in data[counter..counter+16].iter().enumerate() {
            isv_attributes[index] = *val;
        }
        counter += 16;

        let mut isv_mr_enclave = [0u8; 32];
        for (index, val) in data[counter..counter+32].iter().enumerate() {
            isv_mr_enclave[index] = *val;
        }
        counter += 32;

        // The second reserved field, 32 bytes
        counter += 32;

        let mut isv_mr_signer = [0u8; 32];
        for (index, val) in data[counter..counter+32].iter().enumerate() {
            isv_mr_signer[index] = *val;
        }
        counter += 32;

        // The third reserved field, 96 bytes
        counter += 96;

        let isv_prod_id = slice_to_u16(&data[counter..counter+2]);
        counter += 2;

        let isv_svn = slice_to_u16(&data[counter..counter+2]);
        counter += 2;

        // The fourth reserved field, 60 bytes
        counter += 60;

        let mut isv_report_data = [0u8; 64];
        for (index, val) in data[counter..counter+64].iter().enumerate() {
            isv_report_data[index] = *val;
        }
        counter += 64;

        let quote_signature_len = slice_to_u32(&data[counter..counter+4]);
        counter += 4;

        // ECDSA256 report signature structure
        // It seems that future versions will support ECDSA384, so this will need to change

        let mut quote_sig_isv_enclave_report_sig = [0u8; 64];
        for (index, val) in data[counter..counter+64].iter().enumerate() {
            quote_sig_isv_enclave_report_sig[index] = *val;
        }
        counter += 64;

        let mut quote_sig_ecdsa_attestation_key = [0u8; 64];
        for (index, val) in data[counter..counter+64].iter().enumerate() {
            quote_sig_ecdsa_attestation_key[index] = *val;
        }
        counter += 64;

        let mut quote_sig_report_cpu_svn = [0u8; 16];
        for (index, val) in data[counter..counter+16].iter().enumerate() {
            quote_sig_report_cpu_svn[index] = *val;
        }
        counter += 16;

        let quote_sig_misc_select = slice_to_u32(&data[counter..counter+4]);
        counter += 4;

        // First reserved segment in second enclave report, 28 bytes
        counter += 28;

        let mut quote_isv_attributes = [0u8;16];
        for (index, val) in data[counter..counter+16].iter().enumerate() {
            quote_isv_attributes[index] = *val;
        }
        counter += 16;

        let mut quote_sig_isv_mr_enclave = [0u8; 32];
        for (index, val) in data[counter..counter+32].iter().enumerate() {
            quote_sig_isv_mr_enclave[index] = *val;
        }
        counter += 32;

        // Second reserved segment in second enclave report, 32 bytes
        counter += 32;

        let mut quote_sig_isv_mr_signer = [0u8; 32];
        for (index, val) in data[counter..counter+32].iter().enumerate() {
            quote_sig_isv_mr_signer[index] = *val;
        }
        counter += 32;

        // Third reserved segment in second enclave report, 96 bytes
        counter += 96;

        let quote_sig_isv_prod_id = slice_to_u16(&data[counter..counter+2]);
        counter += 2;

        let quote_sig_isv_svn = slice_to_u16(&data[counter..counter+2]);
        counter += 2;

        // Fourth reserved segment in second enclave report, 60 bytes
        counter += 60;

        let mut quote_sig_isv_report_data = [0u8; 64];
        for (index, val) in data[counter..counter+64].iter().enumerate() {
            quote_sig_isv_report_data[index] = *val;
        }
        counter += 64;

        let mut quote_sig_report_signature = [0u8; 64];
        for (index, val) in data[counter..counter+64].iter().enumerate() {
            quote_sig_report_signature[index] = *val;
        }
        counter += 64;

        let quote_qe_auth_data_len = slice_to_u16(&data[counter..counter+2]);
        let mut quote_qu_auth_data:Vec<u8> = Vec::new();
        for val in data[counter..counter+quote_qe_auth_data_len as usize].iter() {
            quote_qu_auth_data.push(*val);
        }
        counter += quote_qe_auth_data_len as usize;

        let quote_qe_certification_type = match slice_to_u16(&data[counter..counter+2]) {
            1 => QECertificationType::PCKidPPIDPlainCPUSVNPCESVN,
            2 => QECertificationType::PCKidPPIDEncryptedRSA2048,
            3 => QECertificationType::PCKidPPIDEncryptedRSA3072,
            4 => QECertificationType::PCKLeafCert,
            5 => QECertificationType::ConcatenatedPCKCertChain,
            7 => QECertificationType::PlatformManifest,
            _ => return Err(anyhow!("invalid quote certification type"))
        };
        counter += 2;

        let quote_certification_data_len = slice_to_u32(&data[counter..counter+4]);
        counter += 4;

        let mut quote_certification_data:Vec<u8> = Vec::new();
        for val in data[counter..counter+quote_certification_data_len as usize].iter() {
            quote_certification_data.push(*val);
        }
        //counter += quote_certification_data_len as usize;

        let quote = Quote{
            header: QuoteHeader {
                version: quote_header_version,
                att_key_type: quote_header_key_type,
                rsvd: 0,
                qe_svn: quote_qe_svn,
                pce_svn: quote_pce_svn,
                qe_vendor_id: quote_qe_vendor_id,
                user_data: quote_user_data
            },
            isv_enclave_report: ISVEnclaveReport {
                cpu_svn: isv_cpu_svn,
                misc_select: isv_misc_select,
                rsvd1: [0u8; 28],
                attributes: isv_attributes,
                mr_enclave: isv_mr_enclave,
                rsvd2: [0u8; 32],
                mr_signer: isv_mr_signer,
                rsvd3: [0u8; 96],
                isv_prod_id: isv_prod_id,
                isv_svn: isv_svn,
                rsvd4: [0u8; 60],
                report_data: isv_report_data
            },
            quote_signature_len: quote_signature_len,
            quote_signature_data: ECDSA256QuoteData {
                isv_enclave_report_signature: quote_sig_isv_enclave_report_sig,
                ecdsa_attestation_key: quote_sig_ecdsa_attestation_key,
                qe_report: ISVEnclaveReport {
                    cpu_svn: quote_sig_report_cpu_svn,
                    misc_select: quote_sig_misc_select,
                    rsvd1: [0u8; 28],
                    attributes: quote_isv_attributes,
                    mr_enclave: quote_sig_isv_mr_enclave,
                    rsvd2: [0u8; 32],
                    mr_signer: quote_sig_isv_mr_signer,
                    rsvd3: [0u8; 96],
                    isv_prod_id: quote_sig_isv_prod_id,
                    isv_svn: quote_sig_isv_svn,
                    rsvd4: [0u8; 60],
                    report_data: quote_sig_isv_report_data,
                },
                qe_report_signature: quote_sig_report_signature,
                qe_authentication_data: QEAuthenticationData {
                    size: quote_qe_auth_data_len,
                    data: quote_qu_auth_data
                },
                qe_certification_data: QECertificationData {
                    certification_data_type: quote_qe_certification_type,
                    size: quote_certification_data_len,
                    data: quote_certification_data
                }
            }
        };
        Ok(quote)
    }
}

impl ExtVerifier for Sgx {
    const OID: ObjectIdentifier = ObjectIdentifier::new_unwrap("1.3.6.1.4.1.58270.1.2");
    const ATT: bool = true;

    fn verify(&self, cri: &CertReqInfo<'_>, ext: &Extension<'_>, dbg: bool) -> Result<bool> {
        if ext.critical {
            return Err(anyhow!("snp extension cannot be critical"));
        }

        // Decode the evidence.
        let evidence = Evidence::from_der(ext.extn_value)?;

        // Validate the PCK.
        let pck = self.is_trusted(&evidence.pck)?;

        // Force certs to have the same key type as the PCK.
        //
        // A note about this check is in order. We don't want to build crypto
        // algorithm negotiation into this protocol. Not only is it complex
        // but it is also subject to downgrade attacks. For example, if the
        // weakest link in the certificate chain is a P384 key and the
        // attacker downgrades the negotiation to P256, it has just weakened
        // security for the whole chain.
        //
        // We solve this by using forcing the certification request to have
        // the same key type as the VCEK. This means we have no worse security
        // than whatever AMD chose for the VCEK.
        //
        // Additionally, we do this check early to be defensive.
        if cri.public_key.algorithm != pck.subject_public_key_info.algorithm {
            return Err(anyhow!("snp vcek algorithm mismatch"));
        }

        let report = Quote::from_bytes(evidence.quote)?;
        eprintln!("SGX report struct: {:?}", report);

        // TODO: validate report
        if !dbg {}

        Ok(true)
    }
}
